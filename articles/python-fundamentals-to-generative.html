<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Da Python Fundamentals a Generative Programming</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            line-height: 1.6;
            color: #1a1a2e;
            background: linear-gradient(135deg, #f5f7fa 0%, #e4e8ec 100%);
            min-height: 100vh;
        }
        
        .container {
            max-width: 1000px;
            margin: 0 auto;
            background: white;
            box-shadow: 0 20px 60px rgba(0,0,0,0.1);
        }
        
        header {
            background: linear-gradient(135deg, #306998 0%, #FFD43B 100%);
            color: white;
            padding: 60px 40px;
            text-align: center;
        }
        
        header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.2);
        }
        
        header .subtitle {
            font-size: 1.2em;
            opacity: 0.95;
            font-style: italic;
        }
        
        .meta-info {
            background: rgba(0,0,0,0.1);
            padding: 15px;
            margin-top: 20px;
            border-radius: 8px;
            font-size: 0.9em;
        }
        
        nav {
            background: #f8f9fa;
            padding: 20px 40px;
            border-bottom: 2px solid #e0e0e0;
            position: sticky;
            top: 0;
            z-index: 100;
            box-shadow: 0 2px 10px rgba(0,0,0,0.05);
        }
        
        nav ul {
            list-style: none;
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            justify-content: center;
        }
        
        nav a {
            color: #306998;
            text-decoration: none;
            font-weight: 500;
            transition: color 0.3s;
            font-size: 0.9em;
            padding: 5px 10px;
            border-radius: 4px;
        }
        
        nav a:hover {
            color: #FFD43B;
            background: rgba(48, 105, 152, 0.1);
        }
        
        main {
            padding: 40px;
        }
        
        section {
            margin-bottom: 60px;
        }
        
        h2 {
            color: #306998;
            font-size: 2em;
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 3px solid #306998;
        }
        
        h3 {
            color: #FFD43B;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.1);
            font-size: 1.5em;
            margin-top: 30px;
            margin-bottom: 15px;
        }
        
        h4 {
            color: #555;
            font-size: 1.2em;
            margin-top: 20px;
            margin-bottom: 10px;
        }
        
        p {
            margin-bottom: 15px;
            text-align: justify;
        }
        
        ul, ol {
            margin-left: 30px;
            margin-bottom: 15px;
        }
        
        li {
            margin-bottom: 8px;
        }
        
        .intro-box {
            background: linear-gradient(135deg, #e8f4f8 0%, #f0f8ff 100%);
            border-left: 4px solid #306998;
            padding: 25px;
            margin: 20px 0;
            border-radius: 0 8px 8px 0;
        }
        
        .intro-box h3 {
            color: #306998;
            text-shadow: none;
            margin-top: 0;
        }
        
        .highlight-box {
            background: #fff3cd;
            border-left: 4px solid #ffc107;
            padding: 20px;
            margin: 20px 0;
            border-radius: 0 8px 8px 0;
        }
        
        .success-box {
            background: #d4edda;
            border-left: 4px solid #28a745;
            padding: 20px;
            margin: 20px 0;
            border-radius: 0 8px 8px 0;
        }
        
        .info-box {
            background: #d1ecf1;
            border-left: 4px solid #17a2b8;
            padding: 20px;
            margin: 20px 0;
            border-radius: 0 8px 8px 0;
        }
        
        code {
            background: #f4f4f4;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'Monaco', 'Menlo', 'Cascadia Code', monospace;
            font-size: 0.9em;
            color: #c7254e;
        }
        
        pre {
            background: #2d2d2d;
            color: #f8f8f2;
            padding: 20px;
            border-radius: 8px;
            overflow-x: auto;
            margin: 20px 0;
            border: 1px solid #444;
        }
        
        pre code {
            background: none;
            color: #f8f8f2;
            padding: 0;
        }
        
        .timeline {
            position: relative;
            padding-left: 30px;
            border-left: 3px solid #306998;
            margin: 30px 0;
        }
        
        .timeline-item {
            margin-bottom: 30px;
            position: relative;
        }
        
        .timeline-item::before {
            content: '';
            position: absolute;
            left: -37px;
            top: 5px;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #FFD43B;
            border: 3px solid #306998;
        }
        
        .timeline-year {
            font-weight: 700;
            color: #306998;
            font-size: 1.1em;
            margin-bottom: 5px;
        }
        
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
        }
        
        th {
            background: #306998;
            color: white;
            padding: 12px;
            text-align: left;
        }
        
        td {
            padding: 10px;
            border-bottom: 1px solid #e0e0e0;
        }
        
        tr:nth-child(even) {
            background: #f8f9fa;
        }
        
        .comparison-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 20px;
            margin: 20px 0;
        }
        
        .comparison-card {
            background: white;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            padding: 20px;
            transition: transform 0.3s, box-shadow 0.3s;
        }
        
        .comparison-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
        }
        
        .comparison-card h4 {
            margin-top: 0;
            color: #306998;
        }
        
        .pattern-card {
            background: #f8f9fa;
            border-left: 4px solid #FFD43B;
            padding: 20px;
            margin: 15px 0;
            border-radius: 0 8px 8px 0;
        }
        
        .pattern-card h4 {
            color: #306998;
            margin-top: 0;
        }
        
        footer {
            background: #2d2d2d;
            color: white;
            padding: 30px 40px;
            text-align: center;
        }
        
        .divider {
            height: 1px;
            background: #e0e0e0;
            margin: 40px 0;
        }
        
        @media (max-width: 768px) {
            header {
                padding: 40px 20px;
            }
            header h1 {
                font-size: 1.8em;
            }
            main, nav, footer {
                padding: 20px;
            }
            .comparison-grid {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>üêç Da Python Fundamentals a Generative Programming</h1>
            <p class="subtitle">Un viaggio dalla curiosit√† sugli iteratori alla generazione procedurale</p>
            <div class="meta-info">
                üìö Bonus Content: Software Engineer 3.0 Journey<br>
                üóìÔ∏è Gennaio 2026 ‚Ä¢ üë§ Software Engineer @ La Tua Azienda
            </div>
        </header>
        
        <nav>
            <ul>
                <li><a href="#intro">Introduzione</a></li>
                <li><a href="#iteratori">Iteratori</a></li>
                <li><a href="#funzioni">Funzioni Comuni</a></li>
                <li><a href="#patterns">Design Patterns</a></li>
                <li><a href="#storia">Storia AI</a></li>
                <li><a href="#generativo">Generativo</a></li>
            </ul>
        </nav>
        
        <main>
            <!-- INTRODUZIONE -->
            <section id="intro">
                <h2>üìñ Introduzione</h2>
                
                <div class="intro-box">
                    <h3>La Genesi di Questo Documento</h3>
                    <p>Questo documento nasce da una semplice domanda: <strong>"Quali sono tutti gli iteratori di Python?"</strong></p>
                    <p>Una curiosit√† genuina che si √® trasformata in un'esplorazione pi√π ampia, attraversando:</p>
                    <ul>
                        <li>Le fondamenta di Python (iteratori, funzioni built-in)</li>
                        <li>I pattern idiomatici che rendono Python unico</li>
                        <li>La storia di come Python √® diventato il linguaggio dell'AI</li>
                        <li>Le tecniche di programmazione generativa per game development</li>
                    </ul>
                    <p>√à un percorso che riflette perfettamente il paradigma del <strong>Software Engineer 3.0</strong>: partire da una domanda specifica, esplorare con curiosit√†, connettere concetti apparentemente distanti, e costruire una comprensione olistica.</p>
                </div>
                
                <p>Questo non √® un tutorial tradizionale. √à la trascrizione di un dialogo esplorativo, dove ogni risposta genera nuove domande, dove la curiosit√† guida l'apprendimento, e dove i concetti si stratificano naturalmente.</p>
                
                <div class="success-box">
                    <strong>üí° Perch√© questo approccio funziona:</strong><br>
                    Invece di studiare Python in modo lineare (capitolo 1, capitolo 2...), abbiamo seguito il flusso della curiosit√†. Questo crea connessioni pi√π profonde e durature. Quando capisci <em>perch√©</em> Python √® diventato il linguaggio dell'AI, comprendi meglio <em>come</em> usarlo efficacemente.
                </div>
            </section>
            
            <div class="divider"></div>
            
            <!-- ITERATORI -->
            <section id="iteratori">
                <h2>üîÑ Iteratori: Il Cuore di Python</h2>
                
                <p>Gli <strong>iteratori</strong> sono oggetti che implementano il protocollo di iterazione, permettendo di attraversare sequenze di elementi uno alla volta. Sono il fondamento della filosofia "lazy evaluation" di Python.</p>
                
                <h3>Iteratori Built-in</h3>
                
                <h4>Sequenze native</h4>
                <pre><code># Liste, tuple, stringhe, range
for item in [1, 2, 3]:
    print(item)

for char in "ciao":
    print(char)

for num in range(5):
    print(num)</code></pre>
                
                <h4>Dizionari e set</h4>
                <pre><code>d = {'a': 1, 'b': 2}

# Itera sulle chiavi
for key in d:
    print(key)

# Itera su coppie chiave-valore
for key, value in d.items():
    print(key, value)

# Solo valori
for value in d.values():
    print(value)</code></pre>
                
                <h4>File</h4>
                <pre><code># Iterano riga per riga - memory efficient
with open('file.txt') as f:
    for line in f:
        print(line.strip())</code></pre>
                
                <h3>Funzioni che restituiscono iteratori</h3>
                
                <div class="pattern-card">
                    <h4>map(), filter(), zip() - Lazy evaluation</h4>
                    <pre><code># map - applica funzione a ogni elemento
nums = [1, 2, 3]
squared = map(lambda x: x**2, nums)
print(list(squared))  # [1, 4, 9]

# filter - filtra elementi
evens = filter(lambda x: x % 2 == 0, range(10))
print(list(evens))  # [0, 2, 4, 6, 8]

# zip - combina iterabili
names = ['Alice', 'Bob']
ages = [25, 30]
for name, age in zip(names, ages):
    print(f"{name}: {age}")</code></pre>
                </div>
                
                <div class="pattern-card">
                    <h4>enumerate() - Aggiunge indice</h4>
                    <pre><code>for i, value in enumerate(['a', 'b', 'c'], start=1):
    print(f"{i}: {value}")
# 1: a
# 2: b
# 3: c</code></pre>
                </div>
                
                <h3>Modulo itertools</h3>
                
                <p>Fornisce iteratori specializzati per pattern comuni:</p>
                
                <pre><code>import itertools

# count - contatore infinito
for i in itertools.count(10, 2):
    if i > 20:
        break
    print(i)  # 10, 12, 14, 16, 18, 20

# cycle - cicla infinitamente
counter = 0
for item in itertools.cycle(['A', 'B', 'C']):
    print(item)
    counter += 1
    if counter >= 7:
        break

# chain - concatena iterabili
for item in itertools.chain([1, 2], [3, 4], [5, 6]):
    print(item)

# combinations e permutations
print(list(itertools.combinations([1, 2, 3], 2)))
# [(1, 2), (1, 3), (2, 3)]

# groupby - raggruppa elementi consecutivi
data = [1, 1, 2, 2, 2, 3, 1]
for key, group in itertools.groupby(data):
    print(key, list(group))</code></pre>
                
                <h3>Creare iteratori personalizzati</h3>
                
                <h4>Con classe</h4>
                <pre><code>class Countdown:
    def __init__(self, start):
        self.current = start
    
    def __iter__(self):
        return self
    
    def __next__(self):
        if self.current <= 0:
            raise StopIteration
        self.current -= 1
        return self.current + 1

for num in Countdown(5):
    print(num)  # 5, 4, 3, 2, 1</code></pre>
                
                <h4>Con generatori (molto pi√π semplice)</h4>
                <pre><code>def countdown(start):
    while start > 0:
        yield start
        start -= 1

for num in countdown(5):
    print(num)</code></pre>
                
                <div class="info-box">
                    <strong>üíé Il Potere della Lazy Evaluation</strong><br>
                    Gli iteratori sono <strong>lazy</strong> - non caricano tutto in memoria ma generano valori quando richiesti. Questo permette di lavorare con sequenze infinite o dataset enormi senza esaurire la RAM.
                </div>
            </section>
            
            <div class="divider"></div>
            
            <!-- FUNZIONI COMUNI -->
            <section id="funzioni">
                <h2>‚öôÔ∏è Le 20 Funzioni Pi√π Comuni</h2>
                
                <p>Queste funzioni built-in coprono l'80% dei casi d'uso quotidiani:</p>
                
                <table>
                    <thead>
                        <tr>
                            <th>Categoria</th>
                            <th>Funzioni</th>
                            <th>Uso</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>I/O</strong></td>
                            <td><code>print()</code>, <code>input()</code></td>
                            <td>Stampa output, legge input utente</td>
                        </tr>
                        <tr>
                            <td><strong>Conversione</strong></td>
                            <td><code>int()</code>, <code>float()</code>, <code>str()</code>, <code>list()</code>, <code>dict()</code></td>
                            <td>Conversione tra tipi</td>
                        </tr>
                        <tr>
                            <td><strong>Matematica</strong></td>
                            <td><code>len()</code>, <code>sum()</code>, <code>min()</code>, <code>max()</code>, <code>abs()</code>, <code>round()</code>, <code>pow()</code></td>
                            <td>Operazioni numeriche comuni</td>
                        </tr>
                        <tr>
                            <td><strong>Iterazione</strong></td>
                            <td><code>range()</code>, <code>enumerate()</code>, <code>zip()</code>, <code>sorted()</code>, <code>reversed()</code></td>
                            <td>Lavorare con sequenze</td>
                        </tr>
                        <tr>
                            <td><strong>Funzionale</strong></td>
                            <td><code>map()</code>, <code>filter()</code></td>
                            <td>Programmare funzionalmente</td>
                        </tr>
                        <tr>
                            <td><strong>Introspezione</strong></td>
                            <td><code>type()</code>, <code>isinstance()</code>, <code>dir()</code>, <code>help()</code></td>
                            <td>Capire oggetti e tipi</td>
                        </tr>
                        <tr>
                            <td><strong>Utilit√†</strong></td>
                            <td><code>open()</code>, <code>all()</code>, <code>any()</code></td>
                            <td>File, valutazione booleana</td>
                        </tr>
                    </tbody>
                </table>
                
                <h3>Esempi Chiave</h3>
                
                <div class="pattern-card">
                    <h4>sorted() - Ordinamento versatile</h4>
                    <pre><code>sorted([3, 1, 4, 1, 5])                    # [1, 1, 3, 4, 5]
sorted(['banana', 'apple'], key=len)       # ['apple', 'banana']
sorted([3, 1, 4], reverse=True)            # [4, 3, 1]</code></pre>
                </div>
                
                <div class="pattern-card">
                    <h4>isinstance() - Type checking sicuro</h4>
                    <pre><code>isinstance(42, int)              # True
isinstance('hello', (int, str))  # True - accetta tuple di tipi</code></pre>
                </div>
            </section>
            
            <div class="divider"></div>
            
            <!-- DESIGN PATTERNS -->
            <section id="patterns">
                <h2>üé® Design Patterns Python</h2>
                
                <p>I pattern idiomatici che rendono Python unico e espressivo:</p>
                
                <h3>1. List Comprehension</h3>
                
                <p>Il pattern pi√π iconico di Python - crea liste in modo conciso:</p>
                
                <pre><code># Base
squares = [x**2 for x in range(10)]

# Con condizione
evens = [x for x in range(20) if x % 2 == 0]

# Con trasformazione condizionale
results = [x if x > 5 else 0 for x in range(10)]

# Nested (appiattire liste)
matrix = [[1, 2], [3, 4], [5, 6]]
flat = [num for row in matrix for num in row]
# [1, 2, 3, 4, 5, 6]

# Con enumerate
indexed = [f"{i}: {val}" for i, val in enumerate(['a', 'b', 'c'])]</code></pre>
                
                <h3>2. Dict & Set Comprehension</h3>
                
                <pre><code># Dict comprehension
squares_dict = {x: x**2 for x in range(5)}
# {0: 0, 1: 1, 2: 4, 3: 9, 4: 16}

# Invertire dizionario
inverted = {v: k for k, v in {'a': 1, 'b': 2}.items()}

# Set comprehension
unique_evens = {x for x in [1, 2, 2, 3, 4, 4] if x % 2 == 0}
# {2, 4}</code></pre>
                
                <h3>3. Unpacking</h3>
                
                <p>Destrutturazione elegante di sequenze:</p>
                
                <pre><code># Base
a, b, c = [1, 2, 3]

# Con *rest
first, *rest = [1, 2, 3, 4, 5]
# first = 1, rest = [2, 3, 4, 5]

first, *middle, last = [1, 2, 3, 4, 5]
# first = 1, middle = [2, 3, 4], last = 5

# Swap elegante
a, b = b, a

# Unpacking in funzioni
def func(x, y, z):
    return x + y + z

args = [1, 2, 3]
func(*args)  # 6

# Merge dizionari (Python 3.9+)
d1 = {'a': 1, 'b': 2}
d2 = {'c': 3, 'd': 4}
merged = {**d1, **d2}</code></pre>
                
                <h3>4. Context Manager (with)</h3>
                
                <pre><code># File
with open('file.txt', 'r') as f:
    content = f.read()
# File chiuso automaticamente

# Multipli
with open('in.txt') as fin, open('out.txt', 'w') as fout:
    fout.write(fin.read())

# Custom context manager
from contextlib import contextmanager

@contextmanager
def timer():
    import time
    start = time.time()
    yield
    print(f"Elapsed: {time.time() - start}s")

with timer():
    sum(range(1000000))</code></pre>
                
                <h3>5. Generator Expression</h3>
                
                <pre><code># Come list comprehension ma lazy
squares = (x**2 for x in range(1000000))  # parentesi invece di []

# Utile con sum, max, any, all
total = sum(x**2 for x in range(1000))
has_even = any(x % 2 == 0 for x in range(10))</code></pre>
                
                <h3>6. Walrus Operator := (Python 3.8+)</h3>
                
                <pre><code># Assignment expression
if (data := get_data()):
    process(data)

# In list comprehension
results = [y for x in range(10) if (y := x**2) > 20]

# In while loop
while (line := file.readline()):
    process(line)</code></pre>
                
                <div class="success-box">
                    <strong>üí° Pattern vs Paradigma</strong><br>
                    Questi pattern non sono solo "sintassi carino". Sono il modo in cui Python esprime concetti complessi in modo leggibile. List comprehension, per esempio, √® pi√π veloce dei loop tradizionali E pi√π facile da leggere.
                </div>
            </section>
            
            <div class="divider"></div>
            
            <!-- STORIA AI -->
            <section id="storia">
                <h2>üèõÔ∏è Come Python √® Diventato il Linguaggio dell'AI</h2>
                
                <div class="intro-box">
                    <h3>La Domanda</h3>
                    <p><em>"Come mai ad un certo punto Python √® diventato il linguaggio dell'AI? Da dove hanno iniziato a pensare 'ok oggi creiamo un algoritmo e usiamo Python'?"</em></p>
                </div>
                
                <p>Python non √® nato per l'AI. √à stata una <strong>convergenza di fattori storici e pratici</strong>.</p>
                
                <h3>La Timeline</h3>
                
                <div class="timeline">
                    <div class="timeline-item">
                        <div class="timeline-year">Anni '50-'90: Le origini</div>
                        <p>L'AI/ML esisteva gi√† in <strong>LISP</strong> e <strong>Prolog</strong> - linguaggi funzionali perfetti per manipolazione simbolica. Problema: lenti, di nicchia, difficili da integrare.</p>
                        <p>Python negli anni '90 cresceva come linguaggio "glue" - ottimo per prototipazione, scripting, collegare librerie C/C++/Fortran.</p>
                    </div>
                    
                    <div class="timeline-item">
                        <div class="timeline-year">2000-2006: Le fondamenta scientifiche</div>
                        <p><strong>NumPy</strong> (2006), <strong>SciPy</strong> (2001), <strong>Matplotlib</strong> (2003) - portano in Python la potenza di MATLAB ma con sintassi pi√π accessibile.</p>
                        <p>I ricercatori potevano scrivere codice leggibile che girava veloce (C ottimizzato sotto).</p>
                    </div>
                    
                    <div class="timeline-item">
                        <div class="timeline-year">2007-2010: L'ecosistema ML</div>
                        <p><strong>scikit-learn</strong> (2007) - Game changer. Interfaccia unificata, consistente per tutti gli algoritmi ML.</p>
                        <pre><code>from sklearn.ensemble import RandomForestClassifier
model = RandomForestClassifier()
model.fit(X_train, y_train)
predictions = model.predict(X_test)</code></pre>
                        <p>Era semplicissimo. Un PhD poteva insegnare ML senza far impazzire gli studenti.</p>
                    </div>
                    
                    <div class="timeline-item">
                        <div class="timeline-year">2010-2015: Deep Learning esplode</div>
                        <p><strong>Theano</strong> (2007) - Python frontend, compilava a CUDA per GPU.</p>
                        <p><strong>TensorFlow</strong> (2015, Google) - inizialmente complesso ma potente.</p>
                        <p><strong>PyTorch</strong> (2016, Facebook) - game changer. Pythonic, dinamico, adorato dai ricercatori.</p>
                    </div>
                    
                    <div class="timeline-item">
                        <div class="timeline-year">2017-oggi: Era Transformer e LLM</div>
                        <p>"Attention is All You Need" (2017) - codice reference in Python/PyTorch.</p>
                        <p>GPT, BERT, tutti i modelli - Python.</p>
                        <p><strong>Hugging Face</strong> - ecosistema intero per LLM, tutto Python.</p>
                    </div>
                </div>
                
                <h3>Perch√© Python Vinse</h3>
                
                <div class="comparison-grid">
                    <div class="comparison-card">
                        <h4>‚ùå Contro C++</h4>
                        <ul>
                            <li>Velocissimo ma boilerplate infernale</li>
                            <li>Debugging complicato</li>
                            <li>Cicli sviluppo lentissimi</li>
                        </ul>
                        <p><strong>Python:</strong> prototipa in ore, non settimane</p>
                    </div>
                    
                    <div class="comparison-card">
                        <h4>‚ùå Contro Java</h4>
                        <ul>
                            <li>Troppo verboso</li>
                            <li>Ecosistema scientifico debole</li>
                            <li>JVM overhead</li>
                        </ul>
                        <p><strong>Python:</strong> conciso e scientifico</p>
                    </div>
                    
                    <div class="comparison-card">
                        <h4>‚ùå Contro R</h4>
                        <ul>
                            <li>Ottimo per statistica</li>
                            <li>Design inconsistente</li>
                            <li>Performance problematiche</li>
                        </ul>
                        <p><strong>Python:</strong> pi√π versatile</p>
                    </div>
                    
                    <div class="comparison-card">
                        <h4>‚ùå Contro MATLAB</h4>
                        <ul>
                            <li>Proprietario, costoso</li>
                            <li>Non adatto a produzione</li>
                        </ul>
                        <p><strong>Python + NumPy:</strong> MATLAB gratis con pi√π features</p>
                    </div>
                </div>
                
                <h3>Il Circolo Virtuoso</h3>
                
                <ol>
                    <li>Ricercatori pubblicano paper con codice Python</li>
                    <li>Altri ricercatori usano quel codice (PyTorch/TensorFlow)</li>
                    <li>Startup assumono quei ricercatori</li>
                    <li>Codice di produzione in Python (gi√† scritto)</li>
                    <li>Pi√π aziende ‚Üí pi√π librerie ‚Üí pi√π adozione</li>
                </ol>
                
                <div class="highlight-box">
                    <h4>Il Paradosso Interessante</h4>
                    <p>Python √® <strong>lento</strong>. √à interpretato, dynamically typed, single-threaded (GIL).</p>
                    <p>Ma per AI non importa perch√©:</p>
                    <ul>
                        <li>Il codice Python √® solo "orchestrazione"</li>
                        <li>Il lavoro pesante (matrici, GPU) √® in C/C++/CUDA</li>
                        <li>Hai bisogno di velocit√† di sviluppo, non di runtime</li>
                    </ul>
                    <pre><code># Questo loop Python √® lento
for i in range(1000000):
    result += i * 2

# Ma questo √® velocissimo (NumPy in C)
result = np.sum(np.arange(1000000) * 2)</code></pre>
                </div>
                
                <div class="info-box">
                    <strong>La Risposta Breve</strong><br>
                    Python divenne il linguaggio dell'AI perch√© era <strong>al posto giusto al momento giusto</strong> - abbastanza maturo, abbastanza flessibile, con un ecosistema scientifico gi√† forte. E quando il deep learning esplose, i ricercatori scelsero la produttivit√† sulla performance raw. Una volta che tutti i paper, tutorial, corsi erano in Python, il gioco era fatto.
                </div>
            </section>
            
            <div class="divider"></div>
            
            <!-- GENERATIVO -->
            <section id="generativo">
                <h2>üéÆ Programmazione Generativa per Game Development</h2>
                
                <div class="intro-box">
                    <h3>La Domanda Finale</h3>
                    <p><em>"Se volessi scrivere una funzione generativa in Python per un gioco, quale sarebbe?"</em></p>
                    <p>Ecco dove Python brilla: generazione procedurale di contenuti. Perfetto per roguelike, space games, terreni infiniti.</p>
                </div>
                
                <h3>1. Dungeon/Cave Generator (Cellular Automata)</h3>
                
                <p>Ideale per roguelike o giochi esplorativi:</p>
                
                <pre><code>import random
import numpy as np

def generate_cave(width, height, fill_prob=0.45, iterations=4):
    """Genera una caverna usando cellular automata"""
    # Inizializza con rumore casuale
    grid = np.random.choice([0, 1], size=(height, width), 
                           p=[1-fill_prob, fill_prob])
    
    # Applica regole cellular automata
    for _ in range(iterations):
        new_grid = grid.copy()
        for y in range(1, height-1):
            for x in range(1, width-1):
                # Conta vicini (muri)
                neighbors = np.sum(grid[y-1:y+2, x-1:x+2]) - grid[y, x]
                
                # Regole: se troppi vicini ‚Üí diventa muro
                if neighbors > 4:
                    new_grid[y, x] = 1
                elif neighbors < 4:
                    new_grid[y, x] = 0
        
        grid = new_grid
    
    return grid  # 0 = vuoto, 1 = muro

# Uso
cave = generate_cave(50, 50)
print(cave)</code></pre>
                
                <h3>2. Perlin Noise per Terreni</h3>
                
                <p>Per generare heightmap, texture, terreni organici:</p>
                
                <pre><code>import noise  # pip install noise
import numpy as np

def generate_terrain(width, height, scale=50.0, octaves=6):
    """Genera heightmap usando Perlin noise"""
    terrain = np.zeros((height, width))
    
    for y in range(height):
        for x in range(width):
            value = noise.pnoise2(x/scale, 
                                  y/scale, 
                                  octaves=octaves,
                                  persistence=0.5,
                                  lacunarity=2.0,
                                  repeatx=width,
                                  repeaty=height,
                                  base=random.randint(0, 1000))
            
            terrain[y][x] = value
    
    # Normalizza 0-1
    terrain = (terrain - terrain.min()) / (terrain.max() - terrain.min())
    return terrain

# Uso per biomi
terrain = generate_terrain(100, 100)
# < 0.3 = acqua, 0.3-0.6 = pianura, > 0.6 = montagna</code></pre>
                
                <h3>3. Wave Function Collapse (WFC)</h3>
                
                <p>Pattern potente per generare level coerenti:</p>
                
                <pre><code>import random

def simple_wfc(tiles, rules, width, height):
    """Simplified Wave Function Collapse"""
    grid = [[None for _ in range(width)] for _ in range(height)]
    
    def get_valid_tiles(x, y):
        valid = set(tiles)
        
        # Controlla ogni direzione
        for dx, dy in [(-1,0), (1,0), (0,-1), (0,1)]:
            nx, ny = x + dx, y + dy
            if 0 <= nx < width and 0 <= ny < height:
                neighbor = grid[ny][nx]
                if neighbor:
                    valid &= set(rules[neighbor])
        
        return list(valid)
    
    # Collapse iterativo
    while None in [cell for row in grid for cell in row]:
        # Trova cella con minima entropia
        min_entropy = float('inf')
        candidates = []
        
        for y in range(height):
            for x in range(width):
                if grid[y][x] is None:
                    valid = get_valid_tiles(x, y)
                    entropy = len(valid)
                    if entropy < min_entropy:
                        min_entropy = entropy
                        candidates = [(x, y, valid)]
                    elif entropy == min_entropy:
                        candidates.append((x, y, valid))
        
        if candidates:
            x, y, valid = random.choice(candidates)
            if valid:
                grid[y][x] = random.choice(valid)
    
    return grid

# Uso
tiles = ['grass', 'water', 'sand', 'forest']
rules = {
    'grass': ['grass', 'sand', 'forest'],
    'water': ['water', 'sand'],
    'sand': ['grass', 'water', 'sand'],
    'forest': ['grass', 'forest']
}
world = simple_wfc(tiles, rules, 20, 20)</code></pre>
                
                <h3>4. Generatore di Sistemi Stellari (Space Game)</h3>
                
                <pre><code>import random
import math

class StarSystem:
    def __init__(self, seed=None):
        if seed:
            random.seed(seed)
        
        self.star = self.generate_star()
        self.planets = self.generate_planets()
    
    def generate_star(self):
        star_types = [
            ('O', 0.00003, (200, 255, 255), 30000),
            ('B', 0.13, (170, 191, 255), 10000),
            ('A', 0.6, (202, 215, 255), 7500),
            ('F', 3.0, (248, 247, 255), 6000),
            ('G', 7.6, (255, 244, 234), 5200),  # nostro sole
            ('K', 12.1, (255, 210, 161), 3700),
            ('M', 76.45, (255, 204, 111), 2400)
        ]
        
        roll = random.uniform(0, 100)
        cumulative = 0
        for star_type, probability, color, temp in star_types:
            cumulative += probability
            if roll <= cumulative:
                return {
                    'type': star_type,
                    'color': color,
                    'temperature': temp,
                    'mass': random.uniform(0.5, 2.0),
                    'radius': random.uniform(0.7, 1.5)
                }
    
    def generate_planets(self):
        num_planets = random.randint(0, 10)
        planets = []
        
        for i in range(num_planets):
            distance = 0.4 + (0.3 * (2 ** i))
            
            planet = {
                'name': f"Planet {i+1}",
                'distance_au': distance,
                'radius_km': random.uniform(2000, 70000),
                'type': self.determine_planet_type(distance),
                'moons': random.randint(0, 5),
                'resources': {
                    'metals': random.randint(0, 100),
                    'water': random.randint(0, 100),
                    'rare_minerals': random.randint(0, 50)
                }
            }
            planets.append(planet)
        
        return planets
    
    def determine_planet_type(self, distance):
        if distance < 0.5:
            return random.choice(['rocky', 'lava'])
        elif 0.5 <= distance < 2.0:
            return random.choice(['rocky', 'terran', 'desert'])
        elif 2.0 <= distance < 5.0:
            return random.choice(['gas_giant', 'ice_giant'])
        else:
            return random.choice(['ice', 'dwarf'])

# Uso
system = StarSystem(seed=12345)
print(f"Star: {system.star['type']}, Temp: {system.star['temperature']}K")
for planet in system.planets:
    print(f"  {planet['name']}: {planet['type']}, "
          f"{planet['distance_au']:.2f} AU")</code></pre>
                
                <h3>5. L-Systems per Vegetazione</h3>
                
                <pre><code>def l_system(axiom, rules, iterations):
    """Lindenmayer system per pattern frattali"""
    current = axiom
    
    for _ in range(iterations):
        next_gen = ""
        for char in current:
            next_gen += rules.get(char, char)
        current = next_gen
    
    return current

# Albero
tree_rules = {
    'F': 'FF+[+F-F-F]-[-F+F+F]',
    '+': '+',
    '-': '-',
    '[': '[',
    ']': ']'
}
tree = l_system('F', tree_rules, 3)</code></pre>
                
                <h3>6. Nome Generator (Markov Chains)</h3>
                
                <pre><code>import random

def markov_name_generator(sample_names, order=2, count=10):
    """Genera nomi usando Markov chains"""
    chain = {}
    for name in sample_names:
        name = '^' * order + name.lower() + '$'
        for i in range(len(name) - order):
            key = name[i:i+order]
            next_char = name[i+order]
            if key not in chain:
                chain[key] = []
            chain[key].append(next_char)
    
    generated = []
    for _ in range(count):
        name = '^' * order
        while True:
            key = name[-order:]
            if key not in chain or name[-1] == '$':
                break
            name += random.choice(chain[key])
        
        generated.append(name[order:-1].capitalize())
    
    return generated

# Uso
planet_samples = ['terra', 'venus', 'mars', 'jupiter']
new_planets = markov_name_generator(planet_samples, order=2, count=5)
print(new_planets)</code></pre>
                
                <div class="success-box">
                    <h4>Per un Space Game</h4>
                    <p>Combinerei:</p>
                    <ol>
                        <li><strong>Perlin noise</strong> per galassie/nebulose</li>
                        <li><strong>StarSystem generator</strong> per sistemi stellari</li>
                        <li><strong>WFC</strong> per stazioni spaziali/interni</li>
                        <li><strong>Markov</strong> per nomi</li>
                    </ol>
                </div>
            </section>
            
            <div class="divider"></div>
            
            <!-- CONCLUSIONI -->
            <section id="conclusioni">
                <h2>üéØ Conclusioni</h2>
                
                <div class="intro-box">
                    <h3>Il Viaggio</h3>
                    <p>Siamo partiti da una domanda tecnica su iteratori e siamo arrivati a:</p>
                    <ul>
                        <li>Comprendere le fondamenta di Python</li>
                        <li>Padroneggiare i pattern idiomatici</li>
                        <li>Capire perch√© Python domina l'AI (storia, ecosistema, network effect)</li>
                        <li>Esplorare la programmazione generativa per game development</li>
                    </ul>
                </div>
                
                <h3>I Takeaway Chiave</h3>
                
                <div class="pattern-card">
                    <h4>1. Python √® un linguaggio di orchestrazione</h4>
                    <p>√à "lento" ma non importa - il lavoro pesante √® in C/CUDA sotto. Python orchestra, non computa.</p>
                </div>
                
                <div class="pattern-card">
                    <h4>2. I pattern sono essenziali</h4>
                    <p>List comprehension, unpacking, context manager - non sono solo "sintassi carina", sono il modo Pythonic di risolvere problemi.</p>
                </div>
                
                <div class="pattern-card">
                    <h4>3. Lazy evaluation = efficienza</h4>
                    <p>Iteratori, generator expression - Python √® lazy per default, il che permette di lavorare con dataset enormi.</p>
                </div>
                
                <div class="pattern-card">
                    <h4>4. Network effect vince</h4>
                    <p>Python vinse nell'AI non perch√© "migliore" tecnicamente, ma perch√© al momento giusto con l'ecosistema giusto. Poi il loop si autoaliment√≤.</p>
                </div>
                
                <div class="pattern-card">
                    <h4>5. Generativo = creativit√† procedurale</h4>
                    <p>Python eccelle nella generazione procedurale - cellular automata, noise functions, L-systems. Perfetto per game dev.</p>
                </div>
                
                <h3>Per il Tuo Percorso Software Engineer 3.0</h3>
                
                <p>Questo documento rappresenta un approccio diverso all'apprendimento:</p>
                
                <ul>
                    <li><strong>Curiosity-driven</strong> - segui le domande, non il syllabus</li>
                    <li><strong>Connessioni trasversali</strong> - da iteratori a storia AI a game dev</li>
                    <li><strong>Pratico ma contestuale</strong> - codice funzionante + perch√© esiste</li>
                    <li><strong>Build, don't just learn</strong> - ogni esempio √® usabile</li>
                </ul>
                
                <div class="highlight-box">
                    <p><strong>Il prossimo passo?</strong></p>
                    <p>Prendi uno di questi generatori e <strong>costruisci qualcosa</strong>. Un dungeon roguelike. Un sistema stellare procedurale. Un generatore di mappe. La teoria si solidifica solo attraverso la pratica.</p>
                </div>
            </section>
        </main>
        
        <footer>
            <p><strong>üêç Da Python Fundamentals a Generative Programming</strong></p>
            <p>Bonus Content: Software Engineer 3.0 Journey</p>
            <p style="margin-top: 20px; opacity: 0.7;">Gennaio 2026 ‚Ä¢ Software Engineer @ La Tua Azienda</p>
            <p style="margin-top: 10px; opacity: 0.7;">Parte della collezione AI Developer Roadmap 2026</p>
        </footer>
    </div>
</body>
</html>